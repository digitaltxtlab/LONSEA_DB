gender(c2[2], method = "demo", years = as.numeric(c2[3]))
gender(c2[2], method = "demo", years = as.numeric(c2[4]))
?gender
gender(c2[2], method = "ssa", years = as.numeric(c2[4]))
test <- gender("madison", method = "demo", years = c(1900, 1985))
class(test)
test <- gender("madison", method = "demo", years = c(1900, 1985))
test
test$gender
test$proportion_female
1 - test$proportion_female
round(1 - test$proportion_female)
gender("madison", method = "demo", years = c(1900, 1985))$proportion_female)
gender("madison", method = "demo", years = c(1900, 1985))$proportion_female
round(1 - gender("madison", method = "demo", years = c(1900, 1985))$proportion_female)
tmp <- rep(NA,length(c2)/2)
tmp
gen[idx]
gen[idx] <- rbinom(length(nm), 1, pr[2])# temporary solution
rbinom(length(nm), 1, pr[2])
main_u.df$gender <- gen
main_u.df$DoB <- NULL # remove date of birth
rm(list=setdiff(ls(), "main_u.df.df"))
#!/usr/bin/Rscript
rm(list = ls())
#"""
# add coded fnames (classes) to main data frame
# build matrix of numerical variables averaged on person (u: unique pname)
# add naitonality
#
#"""
require("gender")
source("data.extract.R")
main.df <- dat2.df; rm(dat2.df)
# import
class.df <- read.csv("data/fname_u_with_class.csv", sep = ",", header = FALSE, stringsAsFactors = FALSE)# changed original category csv due to encoding
# column names
colnames(class.df) = c("u_id", "u_fname" , "u_fname_code")
# code every object in main
tmp <- rep(NA,nrow(main.df))
for(i in 1:nrow(class.df)){
idx <- class.df$u_fname[i] == main.df$fname
tmp[idx] <- class.df$u_fname_code[i]
}
# add column
main.df$fname_code <- tmp
### mdl 1: Average Career Path
## the average career score (fname_code) for each (unique) object (pname)
# number of months in organization
n_months <- function(y1,y2,m1, m2){
y1m1 <- 12 - m1
y2y1 <- y2 - y1
if(y1 < y2){
msum <- msum <- (12 - m1 + m2) + 12 * (y2y1 - 1)}else{
msum = m2-m1
}
if(msum == 0){
msum = 1
}
return(msum)
}
# calculate mode
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
# build matrix
pname_u <- unique(main.df$pname)
nationality_u <- rep(NA,length(pname_u))
# pre-allocate
pname_mat <- matrix(NA,length(pname_u),7)
# generate numeric scores
for(i in 1:length(pname_u)){
idx <- pname_u[i] == main.df$pname
df <- main.df[idx,]
avg <- mean(df$fname_code)
std <- sd(df$fname_code)
if(is.na(std)){std = 0}
med <- median(df$fname_code)
gen <- getmode(df$gender) # gender based on mode of codes
# calculate time spend in LoN
n = nrow(df)
if(n > 1){
y <- c(df$begin_on_year[1], df$end_on_year[n])
m <- c(df$begin_on_month[1],df$end_on_month[n])
}else{
y <- c(df$begin_on_year[1], df$end_on_year[1])
m <- c(df$begin_on_month[1], df$end_on_month[1])
}
# imputation rule: if both years are missing, then NA is upheld, if both months are missing months are assumed identical, if one  year or month is missing the existing value is used
if(sum(is.na(m)) == 1){
m[is.na(m)] = m[!is.na(m)]
}
if(sum(is.na(m)) == 2){
m = c(1,1)
}
if(sum(is.na(y)) == 1){
y[is.na(y)] = y[!is.na(y)]
}
if(sum(is.na(y)) == 2){
dura = NA
}else{
dura <- n_months(y[1],y[2],m[1],m[2])
}
age_entry <- y[1] - mean(df$born_on_year, na.rm = T)
# update matrix
pname_mat[i,1] <- avg
pname_mat[i,2] <- std
pname_mat[i,3] <- med
pname_mat[i,4] <- dura
pname_mat[i,5] <- age_entry
pname_mat[i,6] <- gen
pname_mat[i,7] <- mean(df$born_on_year, na.rm = T)# add year of birth
# string vars
nationality_u[i] <- getmode(unique(df$nationality))
}
# data frame with numerical variables for rank, duration in IoN, entry age, (most frequent) gender, and (most frequent) nationality
main_u.df <- data.frame(pname_u,pname_mat, stringsAsFactors = F)
colnames(main_u.df) = c("name","avg_rank","sd_rank","median_rank","duration","entry_age","gender","DoB")
main_u.df$nationality <- nationality_u
gen <- pname_mat[,6]
gen[is.na(gen)] = -1
idx <- gen == -1
nm <- main_u.df$name[idx]
gen[idx] <- rbinom(length(nm), 1, pr[2])# temporary solution
pr = c(sum(gen[!idx] == 0)/length(gen[!idx]), sum(gen[!idx] == 1)/length(gen[!idx]))
gen[idx] <- rbinom(length(nm), 1, pr[2])# temporary solution
main_u.df$gender <- gen
main_u.df$DoB <- NULL # remove date of birth
rm(list=setdiff(ls(), "main_u.df"))
head(main_u.df)
#!/usr/bin/Rscript
rm(list = ls())
#"""
# add coded fnames (classes) to main data frame
# build matrix of numerical variables averaged on person (u: unique pname)
# add naitonality
#
#"""
require("gender")
source("data.extract.R")
main.df <- dat2.df; rm(dat2.df)
# import
class.df <- read.csv("data/fname_u_with_class.csv", sep = ",", header = FALSE, stringsAsFactors = FALSE)# changed original category csv due to encoding
# column names
colnames(class.df) = c("u_id", "u_fname" , "u_fname_code")
# code every object in main
tmp <- rep(NA,nrow(main.df))
for(i in 1:nrow(class.df)){
idx <- class.df$u_fname[i] == main.df$fname
tmp[idx] <- class.df$u_fname_code[i]
}
# add column
main.df$fname_code <- tmp
### mdl 1: Average Career Path
## the average career score (fname_code) for each (unique) object (pname)
# number of months in organization
n_months <- function(y1,y2,m1, m2){
y1m1 <- 12 - m1
y2y1 <- y2 - y1
if(y1 < y2){
msum <- msum <- (12 - m1 + m2) + 12 * (y2y1 - 1)}else{
msum = m2-m1
}
if(msum == 0){
msum = 1
}
return(msum)
}
# calculate mode
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
# build matrix
pname_u <- unique(main.df$pname)
nationality_u <- rep(NA,length(pname_u))
# pre-allocate
pname_mat <- matrix(NA,length(pname_u),7)
# generate numeric scores
for(i in 1:length(pname_u)){
idx <- pname_u[i] == main.df$pname
df <- main.df[idx,]
avg <- mean(df$fname_code)
std <- sd(df$fname_code)
if(is.na(std)){std = 0}
med <- median(df$fname_code)
gen <- getmode(df$gender) # gender based on mode of codes
# calculate time spend in LoN
n = nrow(df)
if(n > 1){
y <- c(df$begin_on_year[1], df$end_on_year[n])
m <- c(df$begin_on_month[1],df$end_on_month[n])
}else{
y <- c(df$begin_on_year[1], df$end_on_year[1])
m <- c(df$begin_on_month[1], df$end_on_month[1])
}
# imputation rule: if both years are missing, then NA is upheld, if both months are missing months are assumed identical, if one  year or month is missing the existing value is used
if(sum(is.na(m)) == 1){
m[is.na(m)] = m[!is.na(m)]
}
if(sum(is.na(m)) == 2){
m = c(1,1)
}
if(sum(is.na(y)) == 1){
y[is.na(y)] = y[!is.na(y)]
}
if(sum(is.na(y)) == 2){
dura = NA
}else{
dura <- n_months(y[1],y[2],m[1],m[2])
}
age_entry <- y[1] - mean(df$born_on_year, na.rm = T)
# update matrix
pname_mat[i,1] <- avg
pname_mat[i,2] <- std
pname_mat[i,3] <- med
pname_mat[i,4] <- dura
pname_mat[i,5] <- age_entry
pname_mat[i,6] <- gen
pname_mat[i,7] <- mean(df$born_on_year, na.rm = T)# add year of birth
# string vars
nationality_u[i] <- getmode(unique(df$nationality))
}
# data frame with numerical variables for rank, duration in IoN, entry age, (most frequent) gender, and (most frequent) nationality
main_u.df <- data.frame(pname_u,pname_mat, stringsAsFactors = F)
colnames(main_u.df) = c("name","avg_rank","sd_rank","median_rank","duration","entry_age","gender","DoB")
main_u.df$nationality <- nationality_u
# imputation of gender
gen <- pname_mat[,6]
gen[is.na(gen)] = -1
idx <- gen == -1
nm <- main_u.df$name[idx]
db <- main_u.df$DoB[idx]
c1 <- nm[1:4]# esitmate probability from data
c2 <- c(nm[5:6], db[5:6])# esitmate probability from U.S. Social Security Administration
# c1
pr = c(sum(gen[!idx] == 0)/length(gen[!idx]), sum(gen[!idx] == 1)/length(gen[!idx]))
gen[idx] <- rbinom(length(nm), 1, pr[2])# temporary solution
length(gen)
gen_char = rep(NA,length(gen))
gen_char
gen_char[gen == 0] <- 'male'
gen_char[gen == 1] <- 'female'
gen_char
unique(gen_char)
as.factor(gen_char)
main_u.df$gender <- as.factor(gen_char)
main_u.df$gender
main_u.df$DoB <- NULL # remove date of birth
rm(list=setdiff(ls(), "main_u.df"))
head(main_u.df)
colnames(main_u.df)
mdl1 <- lm(avg_rank ~ gender, data = main_u.df)
summary(mdl1)
main_u.df$nationality
main_u.df$nationality == ""
main_u.df$nationality[main_u.df$nationality == ""] = 'unknown'
main_u.df$nationality
main_u.df$nationality <- as.factor(main_u.df$nationality)
main_u.df$nationality
#!/usr/bin/Rscript
rm(list = ls())
#"""
# add coded fnames (classes) to main data frame
# build matrix of numerical variables averaged on person (u: unique pname)
# add naitonality
#
#"""
require("gender")
source("data.extract.R")
main.df <- dat2.df; rm(dat2.df)
# import
class.df <- read.csv("data/fname_u_with_class.csv", sep = ",", header = FALSE, stringsAsFactors = FALSE)# changed original category csv due to encoding
# column names
colnames(class.df) = c("u_id", "u_fname" , "u_fname_code")
# code every object in main
tmp <- rep(NA,nrow(main.df))
for(i in 1:nrow(class.df)){
idx <- class.df$u_fname[i] == main.df$fname
tmp[idx] <- class.df$u_fname_code[i]
}
# add column
main.df$fname_code <- tmp
### mdl 1: Average Career Path
## the average career score (fname_code) for each (unique) object (pname)
# number of months in organization
n_months <- function(y1,y2,m1, m2){
y1m1 <- 12 - m1
y2y1 <- y2 - y1
if(y1 < y2){
msum <- msum <- (12 - m1 + m2) + 12 * (y2y1 - 1)}else{
msum = m2-m1
}
if(msum == 0){
msum = 1
}
return(msum)
}
# calculate mode
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
# build matrix
pname_u <- unique(main.df$pname)
nationality_u <- rep(NA,length(pname_u))
# pre-allocate
pname_mat <- matrix(NA,length(pname_u),7)
# generate numeric scores
for(i in 1:length(pname_u)){
idx <- pname_u[i] == main.df$pname
df <- main.df[idx,]
avg <- mean(df$fname_code)
std <- sd(df$fname_code)
if(is.na(std)){std = 0}
med <- median(df$fname_code)
gen <- getmode(df$gender) # gender based on mode of codes
# calculate time spend in LoN
n = nrow(df)
if(n > 1){
y <- c(df$begin_on_year[1], df$end_on_year[n])
m <- c(df$begin_on_month[1],df$end_on_month[n])
}else{
y <- c(df$begin_on_year[1], df$end_on_year[1])
m <- c(df$begin_on_month[1], df$end_on_month[1])
}
# imputation rule: if both years are missing, then NA is upheld, if both months are missing months are assumed identical, if one  year or month is missing the existing value is used
if(sum(is.na(m)) == 1){
m[is.na(m)] = m[!is.na(m)]
}
if(sum(is.na(m)) == 2){
m = c(1,1)
}
if(sum(is.na(y)) == 1){
y[is.na(y)] = y[!is.na(y)]
}
if(sum(is.na(y)) == 2){
dura = NA
}else{
dura <- n_months(y[1],y[2],m[1],m[2])
}
age_entry <- y[1] - mean(df$born_on_year, na.rm = T)
# update matrix
pname_mat[i,1] <- avg
pname_mat[i,2] <- std
pname_mat[i,3] <- med
pname_mat[i,4] <- dura
pname_mat[i,5] <- age_entry
pname_mat[i,6] <- gen
pname_mat[i,7] <- mean(df$born_on_year, na.rm = T)# add year of birth
# string vars
nationality_u[i] <- getmode(unique(df$nationality))
}
# data frame with numerical variables for rank, duration in IoN, entry age, (most frequent) gender, and (most frequent) nationality
main_u.df <- data.frame(pname_u,pname_mat, stringsAsFactors = F)
colnames(main_u.df) = c("name","avg_rank","sd_rank","median_rank","duration","entry_age","gender","DoB")
main_u.df$nationality <- nationality_u
nationality_u
lower(nationality_u)
main_u.df$nationality <- lowercase(nationality_u)
lower(nationality_u[1])
tolower(nationality_u[1])
tolower(nationality_u)
main_u.df$nationality <- tolower(nationality_u)
#!/usr/bin/Rscript
rm(list = ls())
#"""
# add coded fnames (classes) to main data frame
# build matrix of numerical variables averaged on person (u: unique pname)
# add naitonality
#
#"""
require("gender")
source("data.extract.R")
main.df <- dat2.df; rm(dat2.df)
# import
class.df <- read.csv("data/fname_u_with_class.csv", sep = ",", header = FALSE, stringsAsFactors = FALSE)# changed original category csv due to encoding
# column names
colnames(class.df) = c("u_id", "u_fname" , "u_fname_code")
# code every object in main
tmp <- rep(NA,nrow(main.df))
for(i in 1:nrow(class.df)){
idx <- class.df$u_fname[i] == main.df$fname
tmp[idx] <- class.df$u_fname_code[i]
}
# add column
main.df$fname_code <- tmp
### mdl 1: Average Career Path
## the average career score (fname_code) for each (unique) object (pname)
# number of months in organization
n_months <- function(y1,y2,m1, m2){
y1m1 <- 12 - m1
y2y1 <- y2 - y1
if(y1 < y2){
msum <- msum <- (12 - m1 + m2) + 12 * (y2y1 - 1)}else{
msum = m2-m1
}
if(msum == 0){
msum = 1
}
return(msum)
}
# calculate mode
getmode <- function(v) {
uniqv <- unique(v)
uniqv[which.max(tabulate(match(v, uniqv)))]
}
# build matrix
pname_u <- unique(main.df$pname)
nationality_u <- rep(NA,length(pname_u))
# pre-allocate
pname_mat <- matrix(NA,length(pname_u),7)
# generate numeric scores
for(i in 1:length(pname_u)){
idx <- pname_u[i] == main.df$pname
df <- main.df[idx,]
avg <- mean(df$fname_code)
std <- sd(df$fname_code)
if(is.na(std)){std = 0}
med <- median(df$fname_code)
gen <- getmode(df$gender) # gender based on mode of codes
# calculate time spend in LoN
n = nrow(df)
if(n > 1){
y <- c(df$begin_on_year[1], df$end_on_year[n])
m <- c(df$begin_on_month[1],df$end_on_month[n])
}else{
y <- c(df$begin_on_year[1], df$end_on_year[1])
m <- c(df$begin_on_month[1], df$end_on_month[1])
}
# imputation rule: if both years are missing, then NA is upheld, if both months are missing months are assumed identical, if one  year or month is missing the existing value is used
if(sum(is.na(m)) == 1){
m[is.na(m)] = m[!is.na(m)]
}
if(sum(is.na(m)) == 2){
m = c(1,1)
}
if(sum(is.na(y)) == 1){
y[is.na(y)] = y[!is.na(y)]
}
if(sum(is.na(y)) == 2){
dura = NA
}else{
dura <- n_months(y[1],y[2],m[1],m[2])
}
age_entry <- y[1] - mean(df$born_on_year, na.rm = T)
# update matrix
pname_mat[i,1] <- avg
pname_mat[i,2] <- std
pname_mat[i,3] <- med
pname_mat[i,4] <- dura
pname_mat[i,5] <- age_entry
pname_mat[i,6] <- gen
pname_mat[i,7] <- mean(df$born_on_year, na.rm = T)# add year of birth
# string vars
nationality_u[i] <- getmode(unique(df$nationality))
}
# data frame with numerical variables for rank, duration in IoN, entry age, (most frequent) gender, and (most frequent) nationality
main_u.df <- data.frame(pname_u,pname_mat, stringsAsFactors = F)
colnames(main_u.df) = c("name","avg_rank","sd_rank","median_rank","duration","entry_age","gender","DoB")
main_u.df$nationality <- tolower(nationality_u)
# imputation of gender
gen <- pname_mat[,6]
gen[is.na(gen)] = -1
idx <- gen == -1
nm <- main_u.df$name[idx]
db <- main_u.df$DoB[idx]
c1 <- nm[1:4]# esitmate probability from data
c2 <- c(nm[5:6], db[5:6])# esitmate probability from U.S. Social Security Administration
# c1
pr = c(sum(gen[!idx] == 0)/length(gen[!idx]), sum(gen[!idx] == 1)/length(gen[!idx]))
gen[idx] <- rbinom(length(nm), 1, pr[2])# temporary solution
gen_char = rep(NA,length(gen))
gen_char[gen == 0] <- 'male'
gen_char[gen == 1] <- 'female'
main_u.df$gender <- as.factor(gen_char)
main_u.df$DoB <- NULL # remove date of birth
# fill in nationality
main_u.df$nationality[main_u.df$nationality == ""] = 'unknown'
main_u.df$nationality <- as.factor(main_u.df$nationality)
# update workspace
rm(list=setdiff(ls(), "main_u.df"))
# models for demonstation
colnames(main_u.df)
# rank on gender
mdl1 <- lm(avg_rank ~ gender, data = main_u.df)
mdl1 <- lm(avg_rank ~ duration, data = main_u.df)
mdl2 <- lm(avg_rank ~ duration, data = main_u.df)
summary(mdl2)
mdl1 <- lm(avg_rank ~ gender, data = main_u.df)
summary(mdl1)
mdl_1_2 <- lm(avg_rank ~ gender + duration, data = main_u.df)
summary(mdl_1_2)
mdl1 <- lm(avg_rank ~ gender, data = main_u.df)
summary(mdl1)
mdl_1_2 <- lm(avg_rank ~ gender * duration, data = main_u.df)
summary(mdl_1_2)
colnames(main_u.df)
mdl3 <- lm(avg_rank ~ entry_age, data = main_u.df)
mdl1 <- lm(avg_rank ~ duration, data = main_u.df)
summary(mdl1)
mdl1 <- lm(avg_rank ~ entry_age, data = main_u.df)
summary(mdl2)
mdl3 <- lm(avg_rank ~ gender, data = main_u.df)
summary(mdl3)
colnames(main_u.df)
sum(main_u.df$nationality = "unknown")
sum(main_u.df$nationality == "unknown")
mdl4 <- lm(avg_rank ~ nationality, data = main_u.df)
summary(mdl4)
?lm
